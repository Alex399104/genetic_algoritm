# -*- coding: utf-8 -*-
"""gen_algoritm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1i2rsbGjNAoWzSOiXSGGnC63PueGBhKKY
"""

import random
import time
!pip install deap
from deap import base, creator, tools

# Определение функции оценки
def eval_func(individual):
  target_sum = 15
  return [len(individual) - abs(sum(individual) - target_sum)]

# Создание наборов инструментов
def create_toolbox(num_bits):
  creator.create("FitnessMax", base.Fitness, weights=[1.0,])
  creator.create("Individual", list, fitness=creator.FitnessMax)

  # Инициализация панели инструментов
  toolbox = base.Toolbox()
  toolbox.register("attr_bool", random.randint, 0, 1)
  toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_bool, num_bits)
  toolbox.register("population", tools.initRepeat, list, toolbox.individual)
  toolbox.register("mate", tools.cxTwoPoint)

  # Регистрация оператора оценки
  toolbox.register("evaluate", eval_func)

  # Регистрация оператора мутации
  toolbox.register("mutate", tools.mutFlipBit, indpb = 0.05)

  # Определение оператора для размножения
  toolbox.register("select", tools.selTournament, tournsize = 3)
  return toolbox

if __name__ == "__main__":
  num_bits = 45     # Количество генов в одной особи.   
  toolbox = create_toolbox(num_bits)
  random.seed(7)
  population = toolbox.population(n = 2) # Популяция (количество индивидуумов)
  probab_crossing, probab_mutating = 0.5, 0.2
  num_generations = 0


  best_now_ind = tools.selBest(population, 3)[0]
  start = time.time()

  print('\n Начало процесса эволюции')

  while sum(best_now_ind)!= 15: # 
    
    print("\nПоколение:", num_generations)

    # Оценка всей популяции
    print('Оценка популяции...')
    fitnesses = list(map(toolbox.evaluate, population))
    for ind, fit in zip(population, fitnesses):
      ind.fitness.values = fit

    # Выбор следующего поколения
    offspring = toolbox.select(population, len(population))
  
    # Клонирование выбранных индивидуумов
    offspring = list(map(toolbox.clone, offspring))
  
    # Применение кроссовера и мутации на потомстве
    for child1, child2 in zip(offspring[::2], offspring[1::2]):
      if random.random() < probab_crossing:
        toolbox.mate(child1, child2)

    # Удаление значения фитнеса ребенка
    del child1.fitness.values
    del child2.fitness.values

    # Применение мутации
    for mutant in offspring:
      if random.random() < probab_mutating:
        toolbox.mutate(mutant)
        del mutant.fitness.values

    # Оценка индивидуумов с недопустимой пригодностью
    invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
    fitnesses = map(toolbox.evaluate, invalid_ind)
    for ind, fit in zip(invalid_ind, fitnesses):
      ind.fitness.values = fit
    
    # Замена популяции на следующее поколение
    population[:] = offspring
    best_now_ind = tools.selBest(population, 3)[0]

    print('Лучший индивидуум:\n', best_now_ind)
    print('Количество единиц:', sum(best_now_ind))
    num_generations +=1
  
  print("\nКонец процесса эвалюции\n")
  print("\nКоличество индивидуумов (особей): ", len(population))

  end = time.time()
  print("\nВремя выполнения алгоритма: ", round(end -start,2), " секунд\n")

